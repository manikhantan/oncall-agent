"""Document generation service for analysis reports."""

import json
from datetime import datetime
from pathlib import Path
from typing import Any

from app.core.config import get_settings
from app.core.logging import logger
from app.schemas.analysis import AnalysisFinding


class DocumentService:
    """Service for generating analysis report documents."""

    def __init__(self):
        """Initialize the document service."""
        self.settings = get_settings()

    def generate_document(
        self,
        analysis_id: str,
        timestamp: datetime,
        statistics: dict[str, Any],
        findings: list[AnalysisFinding],
        summary: str,
        recommendations: list[str],
        output_format: str = "markdown"
    ) -> str:
        """Generate an analysis report document.

        Args:
            analysis_id: Unique analysis identifier
            timestamp: Analysis timestamp
            statistics: Log statistics
            findings: List of analysis findings
            summary: Executive summary
            recommendations: List of recommendations
            output_format: Format of the document (markdown or json)

        Returns:
            Path to the generated document
        """
        try:
            filename = f"analysis_{analysis_id}_{timestamp.strftime('%Y%m%d_%H%M%S')}"

            if output_format == "json":
                return self._generate_json_document(
                    filename,
                    analysis_id,
                    timestamp,
                    statistics,
                    findings,
                    summary,
                    recommendations
                )
            else:  # markdown
                return self._generate_markdown_document(
                    filename,
                    analysis_id,
                    timestamp,
                    statistics,
                    findings,
                    summary,
                    recommendations
                )

        except Exception as e:
            logger.error(
                "Failed to generate document",
                extra={"error": str(e), "analysis_id": analysis_id}
            )
            raise

    def _generate_markdown_document(
        self,
        filename: str,
        analysis_id: str,
        timestamp: datetime,
        statistics: dict[str, Any],
        findings: list[AnalysisFinding],
        summary: str,
        recommendations: list[str]
    ) -> str:
        """Generate a markdown format document.

        Args:
            filename: Base filename (without extension)
            analysis_id: Analysis ID
            timestamp: Analysis timestamp
            statistics: Log statistics
            findings: Analysis findings
            summary: Executive summary
            recommendations: Recommendations list

        Returns:
            Path to the generated markdown file
        """
        output_path = Path(self.settings.analysis_output_dir) / f"{filename}.md"

        content = f"""# GCP Log Analysis Report

**Analysis ID:** `{analysis_id}`
**Generated:** {timestamp.strftime('%Y-%m-%d %H:%M:%S UTC')}

---

## Executive Summary

{summary}

---

## Log Statistics

- **Total Logs Analyzed:** {statistics.get('total_count', 0)}
- **Time Range:** {statistics.get('time_range_hours', 0)} hours
- **Logs by Severity:**
"""

        for severity, count in statistics.get('by_severity', {}).items():
            content += f"  - {severity}: {count}\n"

        content += "\n---\n\n## Findings\n\n"

        if not findings:
            content += "*No significant findings.*\n\n"
        else:
            for i, finding in enumerate(findings, 1):
                severity_emoji = self._get_severity_emoji(finding.severity)
                content += f"### {i}. {severity_emoji} {finding.title}\n\n"
                content += f"**Severity:** {finding.severity.upper()}\n\n"
                content += f"**Description:**\n{finding.description}\n\n"

                if finding.affected_logs_count > 0:
                    content += f"**Affected Logs:** {finding.affected_logs_count}\n\n"

                content += f"**Suggested Fix:**\n{finding.suggested_fix}\n\n"

                if finding.code_example:
                    content += "**Code Example:**\n\n```\n"
                    content += finding.code_example
                    content += "\n```\n\n"

                content += "---\n\n"

        content += "## Recommendations\n\n"

        if not recommendations:
            content += "*No additional recommendations.*\n\n"
        else:
            for i, rec in enumerate(recommendations, 1):
                content += f"{i}. {rec}\n"

        content += "\n---\n\n"
        content += "*This report was automatically generated by OnCall Agent.*\n"

        # Write to file
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(content)

        logger.info(
            "Generated markdown document",
            extra={"path": str(output_path)}
        )

        return str(output_path)

    def _generate_json_document(
        self,
        filename: str,
        analysis_id: str,
        timestamp: datetime,
        statistics: dict[str, Any],
        findings: list[AnalysisFinding],
        summary: str,
        recommendations: list[str]
    ) -> str:
        """Generate a JSON format document.

        Args:
            filename: Base filename (without extension)
            analysis_id: Analysis ID
            timestamp: Analysis timestamp
            statistics: Log statistics
            findings: Analysis findings
            summary: Executive summary
            recommendations: Recommendations list

        Returns:
            Path to the generated JSON file
        """
        output_path = Path(self.settings.analysis_output_dir) / f"{filename}.json"

        document = {
            "analysis_id": analysis_id,
            "timestamp": timestamp.isoformat(),
            "summary": summary,
            "statistics": statistics,
            "findings": [
                {
                    "severity": f.severity,
                    "title": f.title,
                    "description": f.description,
                    "affected_logs_count": f.affected_logs_count,
                    "suggested_fix": f.suggested_fix,
                    "code_example": f.code_example
                }
                for f in findings
            ],
            "recommendations": recommendations
        }

        # Write to file
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(document, f, indent=2, ensure_ascii=False)

        logger.info(
            "Generated JSON document",
            extra={"path": str(output_path)}
        )

        return str(output_path)

    def _get_severity_emoji(self, severity: str) -> str:
        """Get an emoji for a severity level.

        Args:
            severity: Severity level

        Returns:
            Emoji string
        """
        emoji_map = {
            "critical": "ğŸ”´",
            "high": "ğŸŸ ",
            "medium": "ğŸŸ¡",
            "low": "ğŸŸ¢",
            "info": "â„¹ï¸"
        }
        return emoji_map.get(severity.lower(), "âšª")
